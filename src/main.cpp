
#include <Arduino.h>
#include <Wire.h>

#define OLED_IMPLEMENTATION
#include "oled.h"

#if defined(AVR_DEBUG)
#include <avr8-stub/avr8-stub.h>
#endif

// Write to EEPROM: https://www.arduino.cc/en/Tutorial/EEPROMRead


// Generated using image2header
const uint8_t _numbers_image[1024] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xe0,0xf0,0xf8,0x3c,0x1c,0x0e,0x0e,0x0e,0x1e,0x3e,0xfc,0xfc,0xf0,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x70,0x70,0x78,0x38,0x3c,0xfc,0xfc,0xfe,0xfe,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x1c,0x1c,0x0e,0x0e,0x0e,0x0e,0x0e,0x1e,0x3e,0xfc,0xfc,0xf8,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x1c,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x1e,0x3e,0xfc,0xfc,0xf8,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0xf0,0x78,0xfe,0xfe,0xfe,0xfe,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xf8,0xfe,0x7e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0xe0,0xf0,0x78,0x78,0x3c,0x1c,0x1e,0x0e,0x0e,0x0e,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x8e,0xee,0xfe,0xfe,0x7e,0x1e,0x06,0x00,0x00,0x00,0x00,0xc0,0xe0,0xf0,0xf8,0x7c,0x1c,0x1e,0x0e,0x0e,0x0e,0x0e,0x3e,0xfc,0xfc,0xf8,0xe0,0x00,0x00,0x00,0x80,0xc0,0xf0,0xf8,0x78,0x3c,0x1c,0x0e,0x0e,0x0e,0x0e,0x1e,0x3e,0xfc,0xf8,0xf0,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0xf0,0xfc,0xff,0xff,0x1f,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0xff,0xff,0xff,0x3f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xf0,0xff,0xff,0x3f,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xe0,0xe0,0xf0,0x70,0x7c,0x3f,0x1f,0x0f,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0xf0,0x78,0x3c,0x1f,0x07,0x03,0xc1,0xfe,0xff,0xff,0x3f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x7c,0x7f,0x7f,0x73,0x70,0xf0,0xf0,0xe0,0xe0,0xc0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xf0,0xfc,0xff,0xbf,0xcf,0xe3,0x61,0x70,0x70,0xf0,0xf0,0xe0,0xe0,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0xf0,0xfc,0xff,0x3f,0x0f,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x3f,0x7f,0xff,0xf0,0xe0,0xc0,0xc0,0xc0,0xe0,0x70,0x7c,0x3f,0x1f,0x0f,0x03,0x00,0x00,0xfc,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xff,0xff,0xff,0x7f,0x00,0x00,0x00,0x00,0x78,0xfc,0xfc,0xfc,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xf0,0xff,0xff,0x7f,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xfc,0xff,0xff,0xff,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0xe0,0xf0,0x78,0x3c,0x1f,0x0f,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x03,0x03,0x0f,0xff,0xff,0xfe,0xf8,0x00,0x00,0x00,0x00,0x00,0x60,0x78,0x7c,0x7e,0x77,0x73,0x71,0x70,0x70,0x70,0xf0,0xfc,0xff,0xff,0xff,0x77,0x70,0x70,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0xfc,0xff,0xff,0xff,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xff,0xff,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xe0,0xf8,0xfe,0x7f,0x1f,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xf0,0xf8,0xfc,0x3e,0x0f,0x07,0x03,0x01,0x01,0x01,0x03,0x07,0x0f,0xff,0xfe,0xfc,0xf0,0x00,0x00,0x00,0x00,0x01,0x07,0x0f,0x0f,0x1f,0x1e,0x1c,0x1c,0x1c,0x0c,0x8e,0xe6,0xfb,0xff,0x3f,0x0f,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x07,0x1f,0x3f,0x7f,0xf8,0xf0,0xe0,0xe0,0xe0,0x70,0x78,0x3e,0x3f,0x0f,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xe0,0xf0,0xf8,0xfc,0xee,0xef,0xe7,0xe3,0xe1,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0x00,0x00,0x00,0x00,0x40,0xf0,0xf0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xf0,0x70,0x78,0x3e,0x1f,0x0f,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xf0,0xf0,0xe0,0xe0,0xe0,0xe0,0xe0,0xf0,0x70,0x78,0x3c,0x3f,0x1f,0x0f,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x1f,0x3f,0x7f,0x7c,0xf0,0xe0,0xe0,0xe0,0xf0,0x70,0x7c,0x3f,0x1f,0x0f,0x03,0x00,0x00,0x00,0x00,0x80,0xe0,0xf8,0xfc,0xff,0x3f,0x0f,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x1f,0x3f,0x7f,0x78,0xf0,0xe0,0xe0,0xe0,0xe0,0xe0,0x70,0x78,0x7c,0x3f,0x1f,0x0f,0x03,0x00,0x00,0x00,0xe0,0xe0,0xe0,0xe0,0xe0,0x70,0x70,0x38,0x3c,0x1e,0x1f,0x0f,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0xfc,0xfc,0xfc,0x78,0x00,0x00,0x00,0x00,0x00,0x78,0xfc,0xfc,0xfc,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    };
const OledImage numbers_image = {(uint8_t*)_numbers_image, (uint16_t)256, (uint16_t)32};

const uint8_t numbers_max_width = 21;
const OledRect number_glyphs[] = {
    {  2, 0, 19, 32 },  // 0
    { 27, 0, 11, 32 },  // 1
    { 41, 0, 20, 32 },  // 2
    { 62, 0, 19, 32 },  // 3
    { 84, 0, 19, 32 },  // 4
    {104, 0, 20, 32 },  // 5
    {126, 0, 18, 32 },  // 6
    {146, 0, 21, 32 },  // 7
    {167, 0, 20, 32 },  // 8
    {188, 0, 19, 32 },  // 9
    {208, 0,  8, 32 },  // :
    {218, 0,  5, 32 }   // .
};

uint8_t _backbuffer[512] = { 0 };
OledImage backbuffer = {_backbuffer, (uint16_t)128, (uint16_t)32};

enum ETimerMode
{
    TIMER_MODE_RUN,
    TIMER_MODE_SET,
    TIMER_MODE_ALARM,
};

enum ETimerSetMode
{
    TIMER_SET_MODE_SECONDS,
    TIMER_SET_MODE_MINUTES,
};

// CONSTANTS
const int bnPinDown = 5;
const int bnPinSelect = 6;
const int bnPinStart = 7;
const int bnPinUp = 8;
// left to right
const int bnDown    = 0;
const int bnSelect  = 1;
const int bnStart   = 2;
const int bnUp      = 3;

bool buttonsPrev[4] = {false,false,false,false};
bool buttons[4] = {false,false,false,false};

#define PRESSED HIGH

int mode = 0;       // 0 - timer, 1 - game
uint32_t prevtime = 0;  // The previous app time

static void UpdateButtonStates()
{
    for( int i = 0; i < 4; ++i )
        buttonsPrev[i] = buttons[i];
    buttons[bnDown]     = digitalRead(bnPinDown) == PRESSED;
    buttons[bnSelect]   = digitalRead(bnPinSelect) == PRESSED;
    buttons[bnStart]    = digitalRead(bnPinStart) == PRESSED;
    buttons[bnUp]       = digitalRead(bnPinUp) == PRESSED;
}

static bool IsButtonDown(int button)
{
    return buttons[button];
}

static bool IsButtonPressed(int button)
{
    return buttons[button] && !buttonsPrev[button];
}

static bool IsButtonReleased(int button)
{
    return !buttons[button] && buttonsPrev[button];
}

/*
static void UpdateButtonStatesDebug(const String& command)
{
    if(command == "down")
    {
        buttons[bnDown] = true;
    }
    else if(command == "select")
    {
        buttons[bnSelect] = true;
    }
    else if(command == "start")
    {
        buttons[bnStart] = true;
    }
    else if(command == "up")
    {
        buttons[bnUp] = true;
    }
}*/


int timermode = TIMER_MODE_SET; // 0 - set (not running), 1 - running, 2 - alarm
int timersetmode = 0; // 0 - seconds, 1 - minutes
uint32_t timertimeout = 87000; // The timeout in milliseconds
uint32_t timertime = 0;
uint32_t timerblinktime = 0;
uint8_t timerblinkflag = 0; // 0 = off, 1 = on

// Display time:
// >= 60 minutes: 1:14h  where the ":" blinks on and off every second
// < 60 minutes: 59:14 where the seconds are simply counting down


static void TimerDisplay()
{
    //oled_clear();

    uint32_t timeleft = timertimeout - timertime;
    uint16_t minutes = timeleft / 60000;
    uint16_t seconds = (timeleft / 1000) % 60;

    uint32_t x = 100;
    uint32_t v = 0;
    uint32_t w = 0;

    bool show_seconds = timermode != TIMER_MODE_SET || timersetmode == TIMER_SET_MODE_MINUTES || timerblinkflag;
    bool show_minutes = timermode != TIMER_MODE_SET || timersetmode == TIMER_SET_MODE_SECONDS || timerblinkflag;

    OledRect dstrect = {0, 0, 0, 32};
    
    v = seconds % 10;
    w = number_glyphs[v].width;
    dstrect.x = x - w;
    dstrect.width = w;

    if( show_seconds ) {
        oled_blit_img(&numbers_image, &number_glyphs[v], &backbuffer, &dstrect);
    } else {
        dstrect.x = x - numbers_max_width;
        dstrect.width = numbers_max_width;
        oled_fill_rect(&backbuffer, &dstrect, 0);
    }

    x -= numbers_max_width;

    seconds = seconds / 10;
    v = seconds % 10;
    w = number_glyphs[v].width;
    dstrect.x = x - w;
    dstrect.width = w;

    if( show_seconds ) {
        oled_blit_img(&numbers_image, &number_glyphs[v], &backbuffer, &dstrect);
    } else {
        dstrect.x = x - numbers_max_width;
        dstrect.width = numbers_max_width;
        oled_fill_rect(&backbuffer, &dstrect, 0);
    }

    x -= numbers_max_width;

    v = 10; // ":"
    w = number_glyphs[v].width;
    dstrect.x = x - w;
    dstrect.width = w;
    oled_blit_img(&numbers_image, &number_glyphs[v], &backbuffer, &dstrect);

    x -= w;

    v = minutes % 10;
    w = number_glyphs[v].width;
    dstrect.x = x - w;
    dstrect.width = w;

    if( show_minutes ) {
        oled_blit_img(&numbers_image, &number_glyphs[v], &backbuffer, &dstrect);
    } else {
        oled_fill_rect(&backbuffer, &dstrect, 0);
    }

    x -= numbers_max_width;

    minutes = minutes / 10;
    v = minutes % 10;
    w = number_glyphs[v].width;
    dstrect.x = x - w;
    dstrect.width = w;

    if( show_minutes && v > 0 ) {
        oled_blit_img(&numbers_image, &number_glyphs[v], &backbuffer, &dstrect);
    } else {
        oled_fill_rect(&backbuffer, &dstrect, 0);
    }

    oled_display(backbuffer.img, backbuffer.height/8 * backbuffer.width);
}

static void TimerUpdate(uint32_t millis)
{
    timerblinktime += millis;

    bool display_dirty = false;
    if(timermode == TIMER_MODE_SET)
    {
        if( IsButtonPressed(bnSelect) )
        {
            timersetmode = (timersetmode + 1) & 1;
            timerblinktime = 250;
            timerblinkflag = 0;
            // Serial.print("Select mode");
            // Serial.print(timersetmode);
            display_dirty = true;
        }
        else if( IsButtonReleased(bnStart) )
        {
            if( timertimeout > 0 )
            {
                timermode = TIMER_MODE_RUN;
                timertime = 0;

//                Serial.print("Start timer!");
            }
            display_dirty = true;
        }
        else if( IsButtonPressed(bnUp) )
        {
            timertimeout += timersetmode ? 60000 : 1000;
            display_dirty = true;
            timerblinktime = 0;
            timerblinkflag = 1;
//            Serial.print(timertimeout / 1000);
        }
        else if( IsButtonPressed(bnDown) )
        {
            uint32_t step = timersetmode ? 60000 : 1000;
            if( timertimeout >= step)
                timertimeout -= step;
            else
                timertimeout = 0;
            
            display_dirty = true;
            timerblinktime = 0;
            timerblinkflag = 1;
//            Serial.print(timertimeout / 1000);
        }

        if( timerblinktime > 500 )
        {
            timerblinktime = timerblinktime % 500;
            timerblinkflag = ~timerblinkflag & 1;
            display_dirty = true;
        }

        //delay(500);
    }
    else if(timermode == TIMER_MODE_RUN)
    {
        timertime += millis;
        if( timertime >= timertimeout )
        {
            timermode = TIMER_MODE_ALARM;
            display_dirty = true;
        }

        if( timerblinktime > 1000 )
        {
            timerblinktime = timerblinktime % 1000;
            timerblinkflag = ~timerblinkflag & 1;
            display_dirty = true;
        }
    }
    else if(timermode == TIMER_MODE_ALARM)
    {
        if( IsButtonPressed(bnUp) || IsButtonPressed(bnDown) || IsButtonPressed(bnStart) || IsButtonPressed(bnSelect) )
        {
            timermode = TIMER_MODE_SET; // Back to timer set mode
            timersetmode = 0;
            timertime = 0;
        }

        if( timerblinktime > 500 )
        {
            timerblinktime = timerblinktime % 500;
            timerblinkflag = ~timerblinkflag & 1;
            display_dirty = true;
        }
    }

    if(display_dirty)
        TimerDisplay();

    //delay(200);
}


void setup()
{
#if defined(AVR_DEBUG)
    debug_init();   // initialize the debugger
#endif

    // Debugging
    pinMode(13, OUTPUT);
#if !defined(AVR_DEBUG)
    Serial.begin(9600);
#endif

    // pins
    // ARE they input as default? shave off 4 lines :)
    pinMode(bnPinDown, INPUT);
    pinMode(bnPinSelect, INPUT);
    pinMode(bnPinStart, INPUT);
    pinMode(bnPinUp, INPUT);

    // OLED
    Wire.begin();
    Wire.setClock(400000);

    oled_init(OLED_I2C_ADDRESS, 128, 64);
    oled_clear();

    //memset(_backbuffer, 0xff, sizeof(_backbuffer));
    //memset(_backbuffer, 0xff, sizeof(_backbuffer));
}

void loop()
{
    /*
    digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
    delay(300);
    digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
    delay(300);
    */

    //String command;
    // while (Serial.available()) {
    //     delay(2);  //delay to allow byte to arrive in input buffer
    //     char c = Serial.read();
    //     command += c;
    // }


    uint32_t time = millis();
    uint32_t deltamillis = time - prevtime;
    if( time < prevtime )
    {
        deltamillis = 0xFFFFFFFF - prevtime + time; // Wrap around every 50 days :/
    }
    prevtime = time;

    if( mode == 0 )
    {
        UpdateButtonStates();
        //UpdateButtonStatesDebug(command);
        TimerUpdate(deltamillis);
    }

}

